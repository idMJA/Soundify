{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 60, "column": 0}, "map": {"version":3,"sources":["file://D%3A/Soundify/src/app/api/spotify/search/route.ts"],"sourcesContent":["import { NextResponse, type NextRequest } from \"next/server\";\n\n/**\n * Interface for Spotify API search response track items\n */\ninterface SpotifyTrack {\n\tid: string;\n\tname: string;\n\turi: string;\n\talbum: {\n\t\tid: string;\n\t\tname: string;\n\t\timages: Array<{\n\t\t\turl: string;\n\t\t\theight: number;\n\t\t\twidth: number;\n\t\t}>;\n\t\trelease_date: string;\n\t\tavailable_markets: string[];\n\t};\n\tartists: Array<{\n\t\tid: string;\n\t\tname: string;\n\t\turi: string;\n\t}>;\n\tduration_ms: number;\n\tpopularity: number;\n\texternal_ids?: {\n\t\tisrc?: string;\n\t};\n\texplicit: boolean;\n}\n\n/**\n * Interface for Spotify API search response playlist items\n */\ninterface SpotifyPlaylist {\n\tid: string;\n\tname: string;\n\tdescription: string;\n\timages: Array<{\n\t\turl: string;\n\t\theight: number | null;\n\t\twidth: number | null;\n\t}>;\n\towner: {\n\t\tid: string;\n\t\tdisplay_name: string;\n\t};\n\turi: string;\n\ttracks: {\n\t\ttotal: number;\n\t};\n}\n\n/**\n * Interface for Spotify API search response\n */\ninterface SpotifySearchResponse {\n\ttracks?: {\n\t\thref: string;\n\t\tlimit: number;\n\t\tnext: string | null;\n\t\toffset: number;\n\t\tprevious: string | null;\n\t\ttotal: number;\n\t\titems: SpotifyTrack[];\n\t};\n\tplaylists?: {\n\t\thref: string;\n\t\tlimit: number;\n\t\tnext: string | null;\n\t\toffset: number;\n\t\tprevious: string | null;\n\t\ttotal: number;\n\t\titems: SpotifyPlaylist[];\n\t};\n}\n\n/**\n * Handles GET requests to search the Spotify API\n */\nexport async function GET(request: NextRequest) {\n\ttry {\n\t\tconst { searchParams } = new URL(request.url);\n\t\tconst query = searchParams.get(\"q\");\n\t\tconst type = searchParams.get(\"type\") || \"track,playlist\";\n\t\tconst limit = searchParams.get(\"limit\") || \"20\";\n\t\tconst offset = searchParams.get(\"offset\") || \"0\";\n\t\tconst isrc = searchParams.get(\"isrc\"); // Get ISRC if provided\n\n\t\tif (!query && !isrc) {\n\t\t\treturn NextResponse.json(\n\t\t\t\t{ error: \"Either query parameter 'q' or 'isrc' is required\" },\n\t\t\t\t{ status: 400 },\n\t\t\t);\n\t\t}\n\n\t\t// First, get a Spotify access token\n\t\tconst tokenResponse = await fetch(\n\t\t\t`${new URL(request.url).origin}/api/spotify/token`,\n\t\t);\n\n\t\tif (!tokenResponse.ok) {\n\t\t\tconst errorText = await tokenResponse.text();\n\t\t\tconsole.error(\"Failed to fetch Spotify token:\", errorText);\n\t\t\treturn NextResponse.json(\n\t\t\t\t{ error: \"Failed to authenticate with Spotify\" },\n\t\t\t\t{ status: tokenResponse.status },\n\t\t\t);\n\t\t}\n\n\t\tconst tokenData = await tokenResponse.json();\n\n\t\t// If ISRC is provided, try searching by ISRC first\n\t\tif (isrc) {\n\t\t\tconsole.log(`Searching Spotify by ISRC: ${isrc}`);\n\n\t\t\tconst isrcUrl = new URL(\"https://api.spotify.com/v1/search\");\n\t\t\tisrcUrl.searchParams.append(\"q\", `isrc:${isrc}`);\n\t\t\tisrcUrl.searchParams.append(\"type\", \"track\");\n\t\t\tisrcUrl.searchParams.append(\"limit\", \"5\"); // Usually just one match for ISRC\n\t\t\tisrcUrl.searchParams.append(\"market\", \"US\");\n\n\t\t\tconst isrcResponse = await fetch(isrcUrl.toString(), {\n\t\t\t\theaders: {\n\t\t\t\t\tAuthorization: `Bearer ${tokenData.accessToken}`,\n\t\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\tAccept: \"application/json\",\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tif (isrcResponse.ok) {\n\t\t\t\tconst isrcData: SpotifySearchResponse = await isrcResponse.json();\n\n\t\t\t\t// If we found tracks by ISRC, return them\n\t\t\t\tif (isrcData.tracks && isrcData.tracks.items.length > 0) {\n\t\t\t\t\tconsole.log(`Found ${isrcData.tracks.items.length} tracks by ISRC`);\n\t\t\t\t\treturn NextResponse.json(isrcData);\n\t\t\t\t}\n\t\t\t\t// Otherwise fall through to regular search\n\t\t\t\tconsole.log(\"No tracks found by ISRC, falling back to regular search\");\n\t\t\t} else {\n\t\t\t\tconsole.log(\n\t\t\t\t\t`ISRC search failed with status ${isrcResponse.status}, falling back to regular search`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Regular search if no ISRC was provided or ISRC search returned no results\n\t\t// Now use the token to search Spotify\n\t\tconst spotifyUrl = new URL(\"https://api.spotify.com/v1/search\");\n\t\tspotifyUrl.searchParams.append(\"q\", query || \"\"); // Use empty string if we got here via ISRC fallback with no query\n\t\tspotifyUrl.searchParams.append(\"type\", type);\n\t\tspotifyUrl.searchParams.append(\"limit\", limit);\n\t\tspotifyUrl.searchParams.append(\"offset\", offset);\n\t\tspotifyUrl.searchParams.append(\"market\", \"US\");\n\n\t\tconsole.log(`Searching Spotify with URL: ${spotifyUrl.toString()}`);\n\n\t\tconst searchResponse = await fetch(spotifyUrl.toString(), {\n\t\t\theaders: {\n\t\t\t\tAuthorization: `Bearer ${tokenData.accessToken}`,\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\tAccept: \"application/json\",\n\t\t\t},\n\t\t});\n\n\t\tif (!searchResponse.ok) {\n\t\t\tconst errorText = await searchResponse.text();\n\t\t\tconsole.error(\n\t\t\t\t`Spotify API search error (${searchResponse.status}):`,\n\t\t\t\terrorText,\n\t\t\t);\n\n\t\t\t// If we get an insufficient scope error, we need to inform the user\n\t\t\t// that we can only access public data with our current auth method\n\t\t\tif (searchResponse.status === 403) {\n\t\t\t\tconsole.log(\n\t\t\t\t\t\"Insufficient scope error - client credentials can only access public data\",\n\t\t\t\t);\n\t\t\t\t// Try again with just the public-facing aspects\n\t\t\t\tspotifyUrl.searchParams.set(\"type\", \"track,artist,album\");\n\n\t\t\t\tconst retryResponse = await fetch(spotifyUrl.toString(), {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\tAuthorization: `Bearer ${tokenData.accessToken}`,\n\t\t\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\t\tAccept: \"application/json\",\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\tif (retryResponse.ok) {\n\t\t\t\t\treturn NextResponse.json(await retryResponse.json());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn NextResponse.json(\n\t\t\t\t{\n\t\t\t\t\terror: `Spotify API error: ${searchResponse.status}`,\n\t\t\t\t\tdetails: errorText,\n\t\t\t\t},\n\t\t\t\t{ status: searchResponse.status },\n\t\t\t);\n\t\t}\n\n\t\tconst searchData: SpotifySearchResponse = await searchResponse.json();\n\n\t\t// Return the raw Spotify search response\n\t\treturn NextResponse.json(searchData);\n\t} catch (error) {\n\t\tconsole.error(\"Spotify search error:\", error);\n\n\t\treturn NextResponse.json(\n\t\t\t{\n\t\t\t\terror: \"Failed to search Spotify\",\n\t\t\t\tdetails: error instanceof Error ? error.message : String(error),\n\t\t\t},\n\t\t\t{ status: 500 },\n\t\t);\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}