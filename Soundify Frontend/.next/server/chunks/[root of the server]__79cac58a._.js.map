{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 60, "column": 0}, "map": {"version":3,"sources":["file://D%3A/Soundify/src/app/api/invidious/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\n\n// Define interfaces for Invidious API responses\ninterface InvidiousVideo {\n\tvideoId: string;\n\ttitle: string;\n\tauthor: string;\n\tauthorId: string;\n\tlengthSeconds: number;\n\tvideoThumbnails: Array<{\n\t\tquality: string;\n\t\turl: string;\n\t\twidth: number;\n\t\theight: number;\n\t}>;\n}\n\n// Define interfaces for stream formats\ninterface InvidiousFormat {\n\turl: string;\n\titag: number;\n\ttype: string;\n\tquality: string;\n\taudioQuality?: string;\n\tcontainer: string;\n\tencoding: string;\n\tbitrate: number;\n}\n\ninterface InvidiousStreamInfo {\n\ttitle: string;\n\tvideoId: string;\n\tauthor: string;\n\tadaptiveFormats: InvidiousFormat[];\n\tformatStreams: InvidiousFormat[];\n}\n\n// You can configure a list of Invidious instances to use\n// If one fails, the system will try another\nconst INVIDIOUS_INSTANCES = [\"https://id.420129.xyz\"];\n\n// Function to search for videos\nexport async function searchVideos(query: string): Promise<InvidiousVideo[]> {\n\tlet lastError: Error | null = null;\n\n\t// Try each instance until one works\n\tfor (const instance of INVIDIOUS_INSTANCES) {\n\t\ttry {\n\t\t\tconsole.log(`Searching using Invidious instance: ${instance}`);\n\t\t\tconst response = await fetch(\n\t\t\t\t`${instance}/api/v1/search?q=${encodeURIComponent(query)}&type=video`,\n\t\t\t\t{\n\t\t\t\t\tcache: \"no-store\",\n\t\t\t\t\tnext: { revalidate: 0 },\n\t\t\t\t\tsignal: AbortSignal.timeout(5000), // 5 second timeout\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!response.ok) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Instance ${instance} returned status: ${response.status}`,\n\t\t\t\t);\n\t\t\t\tlastError = new Error(\n\t\t\t\t\t`Instance ${instance} returned status: ${response.status}`,\n\t\t\t\t);\n\t\t\t\tcontinue; // Try the next instance\n\t\t\t}\n\n\t\t\tconst data = (await response.json()) as InvidiousVideo[];\n\t\t\treturn data;\n\t\t} catch (error) {\n\t\t\tconsole.warn(`Search with instance ${instance} failed:`, error);\n\t\t\tlastError = error instanceof Error ? error : new Error(String(error));\n\t\t\t// Continue to next instance\n\t\t}\n\t}\n\n\t// If we reach here, all instances failed\n\tconsole.error(\"All Invidious instances failed for search\");\n\tthrow lastError || new Error(\"All Invidious instances failed\");\n}\n\n// Function to get streaming URLs for a video\nexport async function getVideoStreams(\n\tvideoId: string,\n): Promise<InvidiousStreamInfo> {\n\tlet lastError: Error | null = null;\n\n\t// Try each instance until one works\n\tfor (const instance of INVIDIOUS_INSTANCES) {\n\t\ttry {\n\t\t\tconsole.log(`Getting video stream from Invidious instance: ${instance}`);\n\t\t\tconst response = await fetch(`${instance}/api/v1/videos/${videoId}`, {\n\t\t\t\tcache: \"no-store\",\n\t\t\t\tnext: { revalidate: 0 },\n\t\t\t\tsignal: AbortSignal.timeout(5000), // 5 second timeout\n\t\t\t});\n\n\t\t\tif (!response.ok) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Instance ${instance} returned status: ${response.status}`,\n\t\t\t\t);\n\t\t\t\tlastError = new Error(\n\t\t\t\t\t`Instance ${instance} returned status: ${response.status}`,\n\t\t\t\t);\n\t\t\t\tcontinue; // Try the next instance\n\t\t\t}\n\n\t\t\tconst data = (await response.json()) as InvidiousStreamInfo;\n\t\t\treturn data;\n\t\t} catch (error) {\n\t\t\tconsole.warn(`Get video stream with instance ${instance} failed:`, error);\n\t\t\tlastError = error instanceof Error ? error : new Error(String(error));\n\t\t\t// Continue to next instance\n\t\t}\n\t}\n\n\t// If we reach here, all instances failed\n\tconsole.error(\"All Invidious instances failed for video streams\");\n\tthrow lastError || new Error(\"All Invidious instances failed\");\n}\n\n// Function to get the best audio stream URL\nexport function getBestAudioStream(\n\tstreamInfo: InvidiousStreamInfo,\n): string | null {\n\t// First try to get an audio-only stream from adaptive formats\n\tconst audioStreams = streamInfo.adaptiveFormats.filter(\n\t\t(format) => format.type.startsWith(\"audio/\") || format.audioQuality,\n\t);\n\n\t// Sort by bitrate (highest first)\n\tconst sortedStreams = [...audioStreams].sort((a, b) => b.bitrate - a.bitrate);\n\n\t// Return the URL of the highest quality audio stream, or null if none found\n\treturn sortedStreams.length > 0 ? sortedStreams[0].url : null;\n}\n\n// Check if our service is available (for health check)\nexport async function GET() {\n\t// Try each instance until one works\n\tfor (const instance of INVIDIOUS_INSTANCES) {\n\t\ttry {\n\t\t\tconsole.log(`Checking health of Invidious instance: ${instance}`);\n\t\t\tconst response = await fetch(`${instance}/api/v1/stats`, {\n\t\t\t\tcache: \"no-store\",\n\t\t\t\tnext: { revalidate: 0 },\n\t\t\t\tsignal: AbortSignal.timeout(3000), // 3 second timeout\n\t\t\t});\n\n\t\t\tif (!response.ok) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Instance ${instance} health check failed with status: ${response.status}`,\n\t\t\t\t);\n\t\t\t\tcontinue; // Try the next instance\n\t\t\t}\n\n\t\t\tconst stats = await response.json();\n\t\t\treturn NextResponse.json({\n\t\t\t\tstatus: \"ok\",\n\t\t\t\tinstance,\n\t\t\t\tstats: {\n\t\t\t\t\tversion: stats.version,\n\t\t\t\t\tsoftware: stats.software,\n\t\t\t\t},\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tconsole.warn(`Health check for instance ${instance} failed:`, error);\n\t\t\t// Continue to next instance\n\t\t}\n\t}\n\n\t// If we reach here, all instances failed\n\tconsole.error(\"All Invidious instances failed health check\");\n\treturn NextResponse.json(\n\t\t{ error: \"All Invidious API instances are not responding\" },\n\t\t{ status: 503 },\n\t);\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 187, "column": 0}, "map": {"version":3,"sources":["file://D%3A/Soundify/src/app/api/piped/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\n\n// Define interfaces for Piped API responses\ninterface PipedVideo {\n\turl: string;\n\ttitle: string;\n\tthumbnail: string;\n\tuploaderName: string;\n\tuploaderUrl: string;\n\tuploaderAvatar: string;\n\tuploadedDate: string;\n\tduration: number;\n\tviews: number;\n\tuploaded: number;\n\tuploaderVerified: boolean;\n\tisShort: boolean;\n}\n\ninterface PipedSearchResult {\n\titems: PipedVideo[];\n\tnextpage: string | null;\n\tsuggestion: string | null;\n\tcorrected: boolean;\n}\n\ninterface PipedStreamFormat {\n\titag: number;\n\tmimeType: string;\n\tbitrate: number;\n\twidth: number;\n\theight: number;\n\tinitStart: number;\n\tinitEnd: number;\n\tindexStart: number;\n\tindexEnd: number;\n\tquality: string;\n\tfps: number;\n\turl: string;\n\taudioTrack?: {\n\t\taudioChannels: number;\n\t\taudioQuality: string;\n\t\taudioSampleRate: number;\n\t};\n}\n\ninterface PipedStreamInfo {\n\ttitle: string;\n\tdescription: string;\n\tuploadDate: string;\n\tuploader: string;\n\tuploaderUrl: string;\n\tuploaderAvatar: string;\n\tthumbnailUrl: string;\n\thls: string | null;\n\tdash: string | null;\n\tlbryId: string | null;\n\tuploaderVerified: boolean;\n\tduration: number;\n\tviews: number;\n\tlikes: number;\n\tdislikes: number;\n\taudioStreams: PipedStreamFormat[];\n\tvideoStreams: PipedStreamFormat[];\n}\n\n// List of Piped instances from https://github.com/TeamPiped/documentation/blob/main/content/docs/public-instances/index.md\nconst PIPED_INSTANCES = [\n\t// \"https://pipedapi.nosebs.ru\",\n\t\"https://pipedapi.drgns.space\",\n\t\"https://pipedapi.ducks.party\",\n\t\"https://api.piped.private.coffee\",\n\t\"https://pipedapi.orangenet.cc\",\n];\n\n// Function to search for videos\nexport async function searchVideos(query: string): Promise<PipedVideo[]> {\n\tlet lastError: Error | null = null;\n\n\t// Try each instance until one works\n\tfor (const instance of PIPED_INSTANCES) {\n\t\ttry {\n\t\t\tconsole.log(`Searching using Piped instance: ${instance}`);\n\t\t\tconst response = await fetch(\n\t\t\t\t`${instance}/search?q=${encodeURIComponent(query)}&filter=videos`,\n\t\t\t\t{\n\t\t\t\t\tcache: \"no-store\",\n\t\t\t\t\tnext: { revalidate: 0 },\n\t\t\t\t\tsignal: AbortSignal.timeout(5000), // 5 second timeout\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (!response.ok) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Piped instance ${instance} returned status: ${response.status}`,\n\t\t\t\t);\n\t\t\t\tlastError = new Error(\n\t\t\t\t\t`Piped instance ${instance} returned status: ${response.status}`,\n\t\t\t\t);\n\t\t\t\tcontinue; // Try the next instance\n\t\t\t}\n\n\t\t\t// Check content type for debugging\n\t\t\tconst contentType = response.headers.get(\"content-type\");\n\t\t\tif (!contentType || !contentType.includes(\"application/json\")) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Piped instance ${instance} returned non-JSON content type: ${contentType}`,\n\t\t\t\t);\n\n\t\t\t\t// Get some response text for debugging\n\t\t\t\tconst text = await response.text();\n\t\t\t\tconsole.warn(`Response starts with: ${text.substring(0, 100)}`);\n\n\t\t\t\tlastError = new Error(\n\t\t\t\t\t`Piped instance ${instance} returned non-JSON content: ${contentType}`,\n\t\t\t\t);\n\t\t\t\tcontinue; // Try the next instance\n\t\t\t}\n\n\t\t\t// Parse JSON after ensuring it's the right content type\n\t\t\tconst data = JSON.parse(await response.text()) as PipedSearchResult;\n\t\t\treturn data.items;\n\t\t} catch (error) {\n\t\t\tconsole.warn(`Search with Piped instance ${instance} failed:`, error);\n\t\t\tlastError = error instanceof Error ? error : new Error(String(error));\n\t\t\t// Continue to next instance\n\t\t}\n\t}\n\n\t// If we reach here, all instances failed\n\tconsole.error(\"All Piped instances failed for search\");\n\tthrow lastError || new Error(\"All Piped instances failed\");\n}\n\n// Function to get streaming URLs for a video\nexport async function getVideoStreams(\n\tvideoId: string,\n): Promise<PipedStreamInfo> {\n\tlet lastError: Error | null = null;\n\n\t// Try each instance until one works\n\tfor (const instance of PIPED_INSTANCES) {\n\t\ttry {\n\t\t\tconsole.log(`Getting video stream from Piped instance: ${instance}`);\n\t\t\tconst response = await fetch(`${instance}/streams/${videoId}`, {\n\t\t\t\tcache: \"no-store\",\n\t\t\t\tnext: { revalidate: 0 },\n\t\t\t\tsignal: AbortSignal.timeout(5000), // 5 second timeout\n\t\t\t});\n\n\t\t\tif (!response.ok) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Piped instance ${instance} returned status: ${response.status}`,\n\t\t\t\t);\n\t\t\t\tlastError = new Error(\n\t\t\t\t\t`Piped instance ${instance} returned status: ${response.status}`,\n\t\t\t\t);\n\t\t\t\tcontinue; // Try the next instance\n\t\t\t}\n\n\t\t\t// Check content type for debugging\n\t\t\tconst contentType = response.headers.get(\"content-type\");\n\t\t\tif (!contentType || !contentType.includes(\"application/json\")) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Piped instance ${instance} returned non-JSON content type: ${contentType}`,\n\t\t\t\t);\n\n\t\t\t\t// Get some response text for debugging\n\t\t\t\tconst text = await response.text();\n\t\t\t\tconsole.warn(`Response starts with: ${text.substring(0, 100)}`);\n\n\t\t\t\tlastError = new Error(\n\t\t\t\t\t`Piped instance ${instance} returned non-JSON content: ${contentType}`,\n\t\t\t\t);\n\t\t\t\tcontinue; // Try the next instance\n\t\t\t}\n\n\t\t\t// Parse JSON after ensuring it's the right content type\n\t\t\tconst data = JSON.parse(await response.text()) as PipedStreamInfo;\n\t\t\treturn data;\n\t\t} catch (error) {\n\t\t\tconsole.warn(\n\t\t\t\t`Get video stream with Piped instance ${instance} failed:`,\n\t\t\t\terror,\n\t\t\t);\n\t\t\tlastError = error instanceof Error ? error : new Error(String(error));\n\t\t\t// Continue to next instance\n\t\t}\n\t}\n\n\t// If we reach here, all instances failed\n\tconsole.error(\"All Piped instances failed for video streams\");\n\tthrow lastError || new Error(\"All Piped instances failed\");\n}\n\n// Function to get the best audio stream URL\nexport function getBestAudioStream(streamInfo: PipedStreamInfo): string | null {\n\t// Get audio streams and sort by bitrate (highest first)\n\tconst sortedStreams = [...streamInfo.audioStreams].sort(\n\t\t(a, b) => b.bitrate - a.bitrate,\n\t);\n\n\t// Return the URL of the highest quality audio stream, or null if none found\n\treturn sortedStreams.length > 0 ? sortedStreams[0].url : null;\n}\n\n// Check if our service is available (for health check)\nexport async function GET() {\n\t// Try each instance until one works\n\tfor (const instance of PIPED_INSTANCES) {\n\t\ttry {\n\t\t\tconsole.log(`Checking health of Piped instance: ${instance}`);\n\t\t\t// Just checking if the API responds\n\t\t\tconst response = await fetch(`${instance}/config`, {\n\t\t\t\tcache: \"no-store\",\n\t\t\t\tnext: { revalidate: 0 },\n\t\t\t\tsignal: AbortSignal.timeout(3000), // 3 second timeout\n\t\t\t});\n\n\t\t\tif (!response.ok) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Piped instance ${instance} health check failed with status: ${response.status}`,\n\t\t\t\t);\n\t\t\t\tcontinue; // Try the next instance\n\t\t\t}\n\n\t\t\t// Check content type for debugging\n\t\t\tconst contentType = response.headers.get(\"content-type\");\n\t\t\tif (!contentType || !contentType.includes(\"application/json\")) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Piped instance ${instance} returned non-JSON content type: ${contentType}`,\n\t\t\t\t);\n\t\t\t\tcontinue; // Try the next instance\n\t\t\t}\n\n\t\t\tconst config = await response.json();\n\t\t\treturn NextResponse.json({\n\t\t\t\tstatus: \"ok\",\n\t\t\t\tinstance,\n\t\t\t\tconfig,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tconsole.warn(\n\t\t\t\t`Health check for Piped instance ${instance} failed:`,\n\t\t\t\terror,\n\t\t\t);\n\t\t\t// Continue to next instance\n\t\t}\n\t}\n\n\t// If we reach here, all instances failed\n\tconsole.error(\"All Piped instances failed health check\");\n\treturn NextResponse.json(\n\t\t{ error: \"All Piped API instances are not responding\" },\n\t\t{ status: 503 },\n\t);\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 341, "column": 0}, "map": {"version":3,"sources":["file://D%3A/Soundify/src/app/api/play/route.ts"],"sourcesContent":["import { type NextRequest, NextResponse } from \"next/server\";\nimport {\n\tgetVideoStreams as getInvidiousStreams,\n\tgetBestAudioStream as getInvidiousBestAudio,\n} from \"../invidious/route\";\nimport {\n\tgetVideoStreams as getPipedStreams,\n\tgetBestAudioStream as getPipedBestAudio,\n} from \"../piped/route\";\n\n// Global object to track playback state\ndeclare global {\n\t/* eslint-disable no-var */\n\tvar currentAudioPlayer: HTMLAudioElement | null;\n\tvar currentTrackId: string | null;\n\t/* eslint-enable no-var */\n}\n\n// Initialize global state if not already present\nif (typeof global.currentAudioPlayer === \"undefined\") {\n\tglobal.currentAudioPlayer = null;\n\tglobal.currentTrackId = null;\n}\n\nexport async function POST(request: NextRequest) {\n\ttry {\n\t\tconst { track } = await request.json();\n\n\t\tif (!track || !track.id) {\n\t\t\treturn NextResponse.json(\n\t\t\t\t{ error: \"Track information is required\" },\n\t\t\t\t{ status: 400 },\n\t\t\t);\n\t\t}\n\n\t\t// Extract preferred service, defaulting to piped\n\t\tconst preferredService = track.preferredService || \"piped\";\n\n\t\ttry {\n\t\t\tlet audioUrl: string | null = null;\n\t\t\tlet title = \"\";\n\t\t\tlet author = \"\";\n\t\t\tlet usedService = preferredService; // Use the preferred service\n\n\t\t\t// Always try the preferred service first (should be piped by default)\n\t\t\tif (preferredService === \"piped\" || usedService === \"piped\") {\n\t\t\t\ttry {\n\t\t\t\t\t// Directly use Piped API for music streaming\n\t\t\t\t\tconsole.log(\"Getting stream with Piped API\");\n\t\t\t\t\tconst pipedStreamInfo = await getPipedStreams(track.id);\n\t\t\t\t\taudioUrl = getPipedBestAudio(pipedStreamInfo);\n\t\t\t\t\ttitle = pipedStreamInfo.title;\n\t\t\t\t\tauthor = pipedStreamInfo.uploader;\n\n\t\t\t\t\t// If Piped fails, only then fall back to Invidious\n\t\t\t\t\tif (!audioUrl) {\n\t\t\t\t\t\tthrow new Error(\"No suitable audio stream found from Piped\");\n\t\t\t\t\t}\n\t\t\t\t} catch (pipedError) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\"Piped streams failed, falling back to Invidious API:\",\n\t\t\t\t\t\tpipedError,\n\t\t\t\t\t);\n\t\t\t\t\tusedService = \"invidious\";\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconsole.log(\"Falling back to Invidious API for streaming\");\n\t\t\t\t\t\tconst streamInfo = await getInvidiousStreams(track.id);\n\t\t\t\t\t\taudioUrl = getInvidiousBestAudio(streamInfo);\n\t\t\t\t\t\ttitle = streamInfo.title;\n\t\t\t\t\t\tauthor = streamInfo.author;\n\n\t\t\t\t\t\tif (!audioUrl) {\n\t\t\t\t\t\t\tthrow new Error(\"No suitable audio stream found from Invidious\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (invidiousError) {\n\t\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t\t\"Both Piped and Invidious streams failed:\",\n\t\t\t\t\t\t\tinvidiousError,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthrow new Error(\"All stream services failed\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (preferredService === \"invidious\") {\n\t\t\t\t// If for some reason Invidious is preferred, try it first\n\t\t\t\ttry {\n\t\t\t\t\tconsole.log(\"Getting stream with Invidious API (as requested)\");\n\t\t\t\t\tconst streamInfo = await getInvidiousStreams(track.id);\n\t\t\t\t\taudioUrl = getInvidiousBestAudio(streamInfo);\n\t\t\t\t\ttitle = streamInfo.title;\n\t\t\t\t\tauthor = streamInfo.author;\n\n\t\t\t\t\tif (!audioUrl) {\n\t\t\t\t\t\tthrow new Error(\"No suitable audio stream found from Invidious\");\n\t\t\t\t\t}\n\t\t\t\t} catch (invidiousError) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\"Invidious streams failed, falling back to Piped API:\",\n\t\t\t\t\t\tinvidiousError,\n\t\t\t\t\t);\n\t\t\t\t\tusedService = \"piped\";\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconsole.log(\"Falling back to Piped API for streaming\");\n\t\t\t\t\t\tconst pipedStreamInfo = await getPipedStreams(track.id);\n\t\t\t\t\t\taudioUrl = getPipedBestAudio(pipedStreamInfo);\n\t\t\t\t\t\ttitle = pipedStreamInfo.title;\n\t\t\t\t\t\tauthor = pipedStreamInfo.uploader;\n\n\t\t\t\t\t\tif (!audioUrl) {\n\t\t\t\t\t\t\tthrow new Error(\"No suitable audio stream found from Piped\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (pipedError) {\n\t\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t\t\"Both Invidious and Piped streams failed:\",\n\t\t\t\t\t\t\tpipedError,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthrow new Error(\"All stream services failed\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!audioUrl) {\n\t\t\t\treturn NextResponse.json(\n\t\t\t\t\t{ error: \"No suitable audio stream found for this track\" },\n\t\t\t\t\t{ status: 404 },\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// If we're already playing something, stop it\n\t\t\tif (global.currentAudioPlayer) {\n\t\t\t\tglobal.currentAudioPlayer.pause();\n\t\t\t\tglobal.currentAudioPlayer = null;\n\t\t\t}\n\n\t\t\t// In a web context, HTMLAudioElement wouldn't exist server-side\n\t\t\t// We're simulating audio playback for the server environment\n\t\t\t// In a real app with client-side playback, this would be handled differently\n\t\t\tglobal.currentTrackId = track.id;\n\n\t\t\treturn NextResponse.json({\n\t\t\t\tstatus: \"playing\",\n\t\t\t\ttrackId: track.id,\n\t\t\t\taudioUrl,\n\t\t\t\ttitle,\n\t\t\t\tauthor,\n\t\t\t\tservice: usedService,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tconsole.error(\"Stream error:\", error);\n\t\t\treturn NextResponse.json(\n\t\t\t\t{ error: \"Failed to get stream information\" },\n\t\t\t\t{ status: 500 },\n\t\t\t);\n\t\t}\n\t} catch (error) {\n\t\tconsole.error(\"Play error:\", error);\n\t\treturn NextResponse.json(\n\t\t\t{ error: \"Failed to play track\" },\n\t\t\t{ status: 500 },\n\t\t);\n\t}\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AAIA;;;;AAaA,iDAAiD;AACjD,IAAI,OAAO,OAAO,kBAAkB,KAAK,aAAa;IACrD,OAAO,kBAAkB,GAAG;IAC5B,OAAO,cAAc,GAAG;AACzB;AAEO,eAAe,KAAK,OAAoB;IAC9C,IAAI;QACH,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,QAAQ,IAAI;QAEpC,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,EAAE;YACxB,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACvB;gBAAE,OAAO;YAAgC,GACzC;gBAAE,QAAQ;YAAI;QAEhB;QAEA,iDAAiD;QACjD,MAAM,mBAAmB,MAAM,gBAAgB,IAAI;QAEnD,IAAI;YACH,IAAI,WAA0B;YAC9B,IAAI,QAAQ;YACZ,IAAI,SAAS;YACb,IAAI,cAAc,kBAAkB,4BAA4B;YAEhE,sEAAsE;YACtE,IAAI,qBAAqB,WAAW,gBAAgB,SAAS;gBAC5D,IAAI;oBACH,6CAA6C;oBAC7C,QAAQ,GAAG,CAAC;oBACZ,MAAM,kBAAkB,MAAM,CAAA,GAAA,qIAAA,CAAA,kBAAe,AAAD,EAAE,MAAM,EAAE;oBACtD,WAAW,CAAA,GAAA,qIAAA,CAAA,qBAAiB,AAAD,EAAE;oBAC7B,QAAQ,gBAAgB,KAAK;oBAC7B,SAAS,gBAAgB,QAAQ;oBAEjC,mDAAmD;oBACnD,IAAI,CAAC,UAAU;wBACd,MAAM,IAAI,MAAM;oBACjB;gBACD,EAAE,OAAO,YAAY;oBACpB,QAAQ,IAAI,CACX,wDACA;oBAED,cAAc;oBAEd,IAAI;wBACH,QAAQ,GAAG,CAAC;wBACZ,MAAM,aAAa,MAAM,CAAA,GAAA,yIAAA,CAAA,kBAAmB,AAAD,EAAE,MAAM,EAAE;wBACrD,WAAW,CAAA,GAAA,yIAAA,CAAA,qBAAqB,AAAD,EAAE;wBACjC,QAAQ,WAAW,KAAK;wBACxB,SAAS,WAAW,MAAM;wBAE1B,IAAI,CAAC,UAAU;4BACd,MAAM,IAAI,MAAM;wBACjB;oBACD,EAAE,OAAO,gBAAgB;wBACxB,QAAQ,KAAK,CACZ,4CACA;wBAED,MAAM,IAAI,MAAM;oBACjB;gBACD;YACD,OAAO,IAAI,qBAAqB,aAAa;gBAC5C,0DAA0D;gBAC1D,IAAI;oBACH,QAAQ,GAAG,CAAC;oBACZ,MAAM,aAAa,MAAM,CAAA,GAAA,yIAAA,CAAA,kBAAmB,AAAD,EAAE,MAAM,EAAE;oBACrD,WAAW,CAAA,GAAA,yIAAA,CAAA,qBAAqB,AAAD,EAAE;oBACjC,QAAQ,WAAW,KAAK;oBACxB,SAAS,WAAW,MAAM;oBAE1B,IAAI,CAAC,UAAU;wBACd,MAAM,IAAI,MAAM;oBACjB;gBACD,EAAE,OAAO,gBAAgB;oBACxB,QAAQ,IAAI,CACX,wDACA;oBAED,cAAc;oBAEd,IAAI;wBACH,QAAQ,GAAG,CAAC;wBACZ,MAAM,kBAAkB,MAAM,CAAA,GAAA,qIAAA,CAAA,kBAAe,AAAD,EAAE,MAAM,EAAE;wBACtD,WAAW,CAAA,GAAA,qIAAA,CAAA,qBAAiB,AAAD,EAAE;wBAC7B,QAAQ,gBAAgB,KAAK;wBAC7B,SAAS,gBAAgB,QAAQ;wBAEjC,IAAI,CAAC,UAAU;4BACd,MAAM,IAAI,MAAM;wBACjB;oBACD,EAAE,OAAO,YAAY;wBACpB,QAAQ,KAAK,CACZ,4CACA;wBAED,MAAM,IAAI,MAAM;oBACjB;gBACD;YACD;YAEA,IAAI,CAAC,UAAU;gBACd,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACvB;oBAAE,OAAO;gBAAgD,GACzD;oBAAE,QAAQ;gBAAI;YAEhB;YAEA,8CAA8C;YAC9C,IAAI,OAAO,kBAAkB,EAAE;gBAC9B,OAAO,kBAAkB,CAAC,KAAK;gBAC/B,OAAO,kBAAkB,GAAG;YAC7B;YAEA,gEAAgE;YAChE,6DAA6D;YAC7D,6EAA6E;YAC7E,OAAO,cAAc,GAAG,MAAM,EAAE;YAEhC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBACxB,QAAQ;gBACR,SAAS,MAAM,EAAE;gBACjB;gBACA;gBACA;gBACA,SAAS;YACV;QACD,EAAE,OAAO,OAAO;YACf,QAAQ,KAAK,CAAC,iBAAiB;YAC/B,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACvB;gBAAE,OAAO;YAAmC,GAC5C;gBAAE,QAAQ;YAAI;QAEhB;IACD,EAAE,OAAO,OAAO;QACf,QAAQ,KAAK,CAAC,eAAe;QAC7B,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACvB;YAAE,OAAO;QAAuB,GAChC;YAAE,QAAQ;QAAI;IAEhB;AACD","debugId":null}}]
}