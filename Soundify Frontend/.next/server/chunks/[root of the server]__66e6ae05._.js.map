{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 164, "column": 0}, "map": {"version":3,"sources":["file://D%3A/Soundify/src/app/api/lavalink/route.ts"],"sourcesContent":["import { LavalinkManager } from \"lavalink-client\";\nimport type { Player } from \"lavalink-client\";\nimport { NextResponse } from \"next/server\";\n\n// Extend LavalinkManager type to include the methods used but not properly typed\ninterface ExtendedLavalinkManager extends LavalinkManager {\n  search?: (options: { query: string; source?: string }) => Promise<unknown>;\n  rest?: Record<string, unknown>;\n  // The original createPlayer returns Player, not Promise<Player>\n  createPlayer(options: {\n    guildId: string;\n    voiceChannelId: string;\n    textChannelId: string;\n    selfDeaf?: boolean;\n    selfMute?: boolean;\n  }): Player;\n}\n\n// Initialize Lavalink client (this should be in a separate file and properly managed)\nlet lavalinkManager: ExtendedLavalinkManager | null = null;\nlet nodeConnected = false;\n\n// Initialize the Lavalink manager if it doesn't exist\nexport async function getLavalinkManager(): Promise<ExtendedLavalinkManager> {\n  if (!lavalinkManager) {\n    console.log(\"Creating new Lavalink manager instance\");\n    // First cast to unknown, then to our extended type to avoid direct incompatible casting\n    const manager = new LavalinkManager({\n      nodes: [\n        {\n          authorization: \"AlyaMahiru\",\n          host: \"localhost\",\n          port: 5556,\n          id: \"main\",\n          secure: false,\n          retryAmount: 5,       // Add retries\n          retryDelay: 3000,     // Retry delay in ms\n        }\n      ],\n      sendToShard: (guildId, payload) => {\n        // This would be handled differently in a web context\n        console.log(`Sending to guild ${guildId}:`, payload);\n      },\n      client: {\n        id: \"Soundify\",\n        username: \"Soundify\",\n      },\n      playerOptions: {\n        defaultSearchPlatform: \"ytmsearch\",\n      }\n    });\n    \n    // Safe casting\n    lavalinkManager = manager as unknown as ExtendedLavalinkManager;\n    \n    try {\n      // Initialize the client\n      await lavalinkManager.init({ id: \"Soundify\", username: \"Soundify\" });\n      \n      // Add node connection event listener\n      lavalinkManager.nodeManager.on(\"connect\", (node) => {\n        console.log(`Node ${node.id} connected successfully!`);\n        nodeConnected = true;\n      });\n      \n      // Add node disconnect event listener\n      lavalinkManager.nodeManager.on(\"disconnect\", (node) => {\n        console.log(`Node ${node.id} disconnected!`);\n        nodeConnected = false;\n      });\n      \n      // Add node error event listener\n      lavalinkManager.nodeManager.on(\"error\", (node, error) => {\n        console.error(`Node ${node.id} encountered an error:`, error);\n        \n        // Handle v4/info error specifically\n        if (error?.message?.includes(\"/v4/info\")) {\n          console.log(\"Version incompatibility detected. The Lavalink server might be using v3 API.\");\n          // The node will try to reconnect automatically with retryAmount\n        }\n      });\n      \n      // Log available methods to help debugging\n      console.log(\"LavalinkManager methods:\", Object.keys(lavalinkManager));\n      console.log(\"Has direct search?\", typeof lavalinkManager.search === 'function');\n      console.log(\"Has REST API?\", !!lavalinkManager.rest);\n      \n      if (lavalinkManager.rest) {\n        console.log(\"REST API methods:\", Object.keys(lavalinkManager.rest));\n      }\n      \n      // Wait for node connection (with timeout)\n      try {\n        await waitForNodeConnection(10000); // Increase timeout to 10 seconds\n      } catch (error) {\n        console.error(\"Error connecting to Lavalink node:\", error);\n        // Continue anyway - the app can handle not having a connected node\n      }\n    } catch (error) {\n      console.error(\"Failed to initialize Lavalink manager:\", error);\n      // Don't throw, just log the error\n      // This allows the app to function even without Lavalink\n    }\n  } else if (!nodeConnected) {\n    // If manager exists but node isn't connected, try to wait for connection\n    try {\n      await waitForNodeConnection(5000);\n    } catch (error) {\n      console.error(\"Error reconnecting to Lavalink node:\", error);\n      // Continue anyway\n    }\n  }\n  \n  return lavalinkManager;\n}\n\n// Function to wait for node connection with timeout\nasync function waitForNodeConnection(timeoutMs = 5000): Promise<void> {\n  return new Promise((resolve, reject) => {\n    // Check if already connected\n    if (nodeConnected) {\n      return resolve();\n    }\n    \n    if (!lavalinkManager) {\n      return reject(new Error(\"LavalinkManager not initialized\"));\n    }\n    \n    // Check if any nodes are connected\n    const connectedNodes = Array.from(lavalinkManager.nodeManager.nodes.values()).filter(node => node.connected);\n    if (connectedNodes.length > 0) {\n      nodeConnected = true;\n      return resolve();\n    }\n    \n    // Set timeout for connection\n    const timeout = setTimeout(() => {\n      cleanup();\n      reject(new Error(\"Timed out waiting for Lavalink node connection\"));\n    }, timeoutMs);\n    \n    // Set up connection event listener\n    const connectHandler = () => {\n      cleanup();\n      nodeConnected = true;\n      resolve();\n    };\n    \n    // Clean up function\n    function cleanup() {\n      clearTimeout(timeout);\n      if (lavalinkManager) {\n        lavalinkManager.nodeManager.removeListener(\"connect\", connectHandler);\n      }\n    }\n    \n    // Listen for connection event\n    lavalinkManager.nodeManager.on(\"connect\", connectHandler);\n    \n    // Try to connect nodes manually\n    for (const node of lavalinkManager.nodeManager.nodes.values()) {\n      if (!node.connected) {\n        node.connect();\n      }\n    }\n  });\n}\n\nexport async function GET(request: Request) {\n  try {\n    const manager = await getLavalinkManager();\n    const nodes = Array.from(manager.nodeManager.nodes.values()).map(node => ({\n      id: node.id,\n      connected: node.connected,\n    }));\n    \n    if (!nodes.some(node => node.connected)) {\n      return NextResponse.json(\n        { error: \"No Lavalink nodes are connected. Make sure your Lavalink server is running.\" }, \n        { status: 503 }\n      );\n    }\n    \n    return NextResponse.json({ status: \"ok\", nodes });\n  } catch (error) {\n    console.error(\"Lavalink error:\", error);\n    const errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n    return NextResponse.json(\n      { error: `Failed to connect to Lavalink: ${errorMessage}` }, \n      { status: 503 }\n    );\n  }\n} "],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 339, "column": 0}, "map": {"version":3,"sources":["file://D%3A/Soundify/src/app/api/search/route.ts"],"sourcesContent":["import { type NextRequest, NextResponse } from \"next/server\";\nimport { getLavalinkManager } from \"../lavalink/route\";\n\n// Our local interface to simplify track handling\ninterface FormattedTrack {\n  id: string;\n  title: string;\n  artist: string;\n  thumbnail: string;\n  duration: number;\n  uri: string;\n}\n\n// Interface for Lavalink track info \ninterface TrackInfo {\n  identifier: string;\n  title?: string;\n  author?: string;\n  artworkUrl?: string;\n  uri?: string;\n  duration?: number;\n  length?: number;\n}\n\n// Basic interface for search results\ninterface SearchResult {\n  tracks?: Array<{\n    info?: TrackInfo;\n    [key: string]: any;\n  }>;\n  [key: string]: any;\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const query = searchParams.get(\"query\");\n    \n    if (!query) {\n      return NextResponse.json(\n        { error: \"Query parameter is required\" }, \n        { status: 400 }\n      );\n    }\n    \n    try {\n      // Get the Lavalink manager and ensure it's connected\n      const manager = await getLavalinkManager();\n      \n      // Verify that at least one node is connected\n      const connectedNodes = Array.from(manager.nodeManager.nodes.values()).filter(node => node.connected);\n      if (connectedNodes.length === 0) {\n        return NextResponse.json(\n          { error: \"No Lavalink nodes are connected. Please make sure your Lavalink server is running.\" }, \n          { status: 503 }\n        );\n      }\n      \n      // Get a connected node to perform the search directly\n      const node = connectedNodes[0];\n      \n      // Use the node's search method directly instead of going through a player\n      console.log(\"Searching using node:\", node.id);\n      \n      let searchResults: SearchResult;\n      try {\n        // Try with ytmsearch first\n        searchResults = await node.search({\n          query,\n          source: \"ytmsearch\",\n        }, \"web\") as SearchResult;\n      } catch (searchError) {\n        console.error(\"Search failed with ytmsearch, trying ytsearch:\", searchError);\n        \n        // If ytmsearch fails, try regular YouTube search\n        try {\n          searchResults = await node.search({\n            query,\n            source: \"ytsearch\",\n          }, \"web\") as SearchResult;\n        } catch (fallbackError) {\n          console.error(\"Fallback search also failed:\", fallbackError);\n          throw new Error(\"All search methods failed\");\n        }\n      }\n      \n      console.log(\"Search results:\", \n        searchResults ? \n        `Found ${searchResults.tracks?.length || 0} tracks` : \n        \"No results\"\n      );\n      \n      if (!searchResults || !searchResults.tracks || !Array.isArray(searchResults.tracks)) {\n        console.log(\"No tracks found in search results\");\n        return NextResponse.json({ tracks: [] });\n      }\n      \n      // Format the results using type guards\n      const tracks: FormattedTrack[] = searchResults.tracks\n        .filter(track => !!track && !!track.info)\n        .map(track => {\n          const info = track.info as TrackInfo;\n          \n          // Extract track info with fallbacks\n          // Using optional chaining and nullish coalescing for safety\n          return {\n            id: info.identifier ?? '',\n            title: info.title ?? 'Unknown Title',\n            artist: info.author ?? 'Unknown Artist',\n            thumbnail: info.artworkUrl ?? \n              `https://img.youtube.com/vi/${info.identifier ?? ''}/mqdefault.jpg`,\n            // The property might be called duration or length depending on the version\n            duration: info.duration ?? info.length ?? 0,\n            uri: info.uri ?? ''\n          };\n        });\n      \n      return NextResponse.json({ tracks });\n    } catch (error) {\n      console.error(\"Search method error:\", error);\n      console.error(\"Error details:\", error instanceof Error ? error.stack : String(error));\n      \n      // Special handling for common Lavalink errors\n      let status = 500;\n      let errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n      \n      if (errorMessage.includes(\"not connected\") || errorMessage.includes(\"No Lavalink nodes\")) {\n        status = 503; // Service Unavailable\n        errorMessage = \"Lavalink server is not connected. Please ensure the server is running.\";\n      } else if (errorMessage.includes(\"does not provide any /v4/info\")) {\n        status = 503; // Service Unavailable\n        errorMessage = \"Lavalink server version incompatibility. The server might be using v3 API.\";\n      }\n      \n      return NextResponse.json(\n        { error: `Lavalink search failed: ${errorMessage}` }, \n        { status }\n      );\n    }\n  } catch (error) {\n    console.error(\"Search error:\", error);\n    const errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n    return NextResponse.json(\n      { error: `Failed to search tracks: ${errorMessage}` }, \n      { status: 500 }\n    );\n  }\n} "],"names":[],"mappings":";;;AAAA;AACA;;;AAgCO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,QAAQ,aAAa,GAAG,CAAC;QAE/B,IAAI,CAAC,OAAO;YACV,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA8B,GACvC;gBAAE,QAAQ;YAAI;QAElB;QAEA,IAAI;YACF,qDAAqD;YACrD,MAAM,UAAU,MAAM,CAAA,GAAA,wIAAA,CAAA,qBAAkB,AAAD;YAEvC,6CAA6C;YAC7C,MAAM,iBAAiB,MAAM,IAAI,CAAC,QAAQ,WAAW,CAAC,KAAK,CAAC,MAAM,IAAI,MAAM,CAAC,CAAA,OAAQ,KAAK,SAAS;YACnG,IAAI,eAAe,MAAM,KAAK,GAAG;gBAC/B,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;oBAAE,OAAO;gBAAqF,GAC9F;oBAAE,QAAQ;gBAAI;YAElB;YAEA,sDAAsD;YACtD,MAAM,OAAO,cAAc,CAAC,EAAE;YAE9B,0EAA0E;YAC1E,QAAQ,GAAG,CAAC,yBAAyB,KAAK,EAAE;YAE5C,IAAI;YACJ,IAAI;gBACF,2BAA2B;gBAC3B,gBAAgB,MAAM,KAAK,MAAM,CAAC;oBAChC;oBACA,QAAQ;gBACV,GAAG;YACL,EAAE,OAAO,aAAa;gBACpB,QAAQ,KAAK,CAAC,kDAAkD;gBAEhE,iDAAiD;gBACjD,IAAI;oBACF,gBAAgB,MAAM,KAAK,MAAM,CAAC;wBAChC;wBACA,QAAQ;oBACV,GAAG;gBACL,EAAE,OAAO,eAAe;oBACtB,QAAQ,KAAK,CAAC,gCAAgC;oBAC9C,MAAM,IAAI,MAAM;gBAClB;YACF;YAEA,QAAQ,GAAG,CAAC,mBACV,gBACA,CAAC,MAAM,EAAE,cAAc,MAAM,EAAE,UAAU,EAAE,OAAO,CAAC,GACnD;YAGF,IAAI,CAAC,iBAAiB,CAAC,cAAc,MAAM,IAAI,CAAC,MAAM,OAAO,CAAC,cAAc,MAAM,GAAG;gBACnF,QAAQ,GAAG,CAAC;gBACZ,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;oBAAE,QAAQ,EAAE;gBAAC;YACxC;YAEA,uCAAuC;YACvC,MAAM,SAA2B,cAAc,MAAM,CAClD,MAAM,CAAC,CAAA,QAAS,CAAC,CAAC,SAAS,CAAC,CAAC,MAAM,IAAI,EACvC,GAAG,CAAC,CAAA;gBACH,MAAM,OAAO,MAAM,IAAI;gBAEvB,oCAAoC;gBACpC,4DAA4D;gBAC5D,OAAO;oBACL,IAAI,KAAK,UAAU,IAAI;oBACvB,OAAO,KAAK,KAAK,IAAI;oBACrB,QAAQ,KAAK,MAAM,IAAI;oBACvB,WAAW,KAAK,UAAU,IACxB,CAAC,2BAA2B,EAAE,KAAK,UAAU,IAAI,GAAG,cAAc,CAAC;oBACrE,2EAA2E;oBAC3E,UAAU,KAAK,QAAQ,IAAI,KAAK,MAAM,IAAI;oBAC1C,KAAK,KAAK,GAAG,IAAI;gBACnB;YACF;YAEF,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE;YAAO;QACpC,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,wBAAwB;YACtC,QAAQ,KAAK,CAAC,kBAAkB,iBAAiB,QAAQ,MAAM,KAAK,GAAG,OAAO;YAE9E,8CAA8C;YAC9C,IAAI,SAAS;YACb,IAAI,eAAe,iBAAiB,QAAQ,MAAM,OAAO,GAAG;YAE5D,IAAI,aAAa,QAAQ,CAAC,oBAAoB,aAAa,QAAQ,CAAC,sBAAsB;gBACxF,SAAS,KAAK,sBAAsB;gBACpC,eAAe;YACjB,OAAO,IAAI,aAAa,QAAQ,CAAC,kCAAkC;gBACjE,SAAS,KAAK,sBAAsB;gBACpC,eAAe;YACjB;YAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO,CAAC,wBAAwB,EAAE,cAAc;YAAC,GACnD;gBAAE;YAAO;QAEb;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iBAAiB;QAC/B,MAAM,eAAe,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAC9D,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,OAAO,CAAC,yBAAyB,EAAE,cAAc;QAAC,GACpD;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}