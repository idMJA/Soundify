{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 60, "column": 0}, "map": {"version":3,"sources":["file://D%3A/Soundify/src/app/api/invidious/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\r\n\r\n// Define interfaces for Invidious API responses\r\ninterface InvidiousVideo {\r\n  videoId: string;\r\n  title: string;\r\n  author: string;\r\n  authorId: string;\r\n  lengthSeconds: number;\r\n  videoThumbnails: Array<{\r\n    quality: string;\r\n    url: string;\r\n    width: number;\r\n    height: number;\r\n  }>;\r\n}\r\n\r\ninterface InvidiousSearchResult {\r\n  videos?: InvidiousVideo[];\r\n}\r\n\r\n// Define interfaces for stream formats\r\ninterface InvidiousFormat {\r\n  url: string;\r\n  itag: number;\r\n  type: string;\r\n  quality: string;\r\n  audioQuality?: string;\r\n  container: string;\r\n  encoding: string;\r\n  bitrate: number;\r\n}\r\n\r\ninterface InvidiousStreamInfo {\r\n  title: string;\r\n  videoId: string;\r\n  author: string;\r\n  adaptiveFormats: InvidiousFormat[];\r\n  formatStreams: InvidiousFormat[];\r\n}\r\n\r\n// You can configure a list of Invidious instances to use\r\n// If one fails, the system will try another\r\nconst INVIDIOUS_INSTANCES = [\r\n  \"https://id.420129.xyz\",\r\n];\r\n\r\n// Function to search for videos\r\nexport async function searchVideos(query: string): Promise<InvidiousVideo[]> {\r\n  let lastError: Error | null = null;\r\n  \r\n  // Try each instance until one works\r\n  for (const instance of INVIDIOUS_INSTANCES) {\r\n    try {\r\n      console.log(`Searching using Invidious instance: ${instance}`);\r\n      const response = await fetch(`${instance}/api/v1/search?q=${encodeURIComponent(query)}&type=video`, {\r\n        cache: 'no-store',\r\n        next: { revalidate: 0 },\r\n        signal: AbortSignal.timeout(5000) // 5 second timeout\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        console.warn(`Instance ${instance} returned status: ${response.status}`);\r\n        lastError = new Error(`Instance ${instance} returned status: ${response.status}`);\r\n        continue; // Try the next instance\r\n      }\r\n      \r\n      const data = await response.json() as InvidiousVideo[];\r\n      return data;\r\n    } catch (error) {\r\n      console.warn(`Search with instance ${instance} failed:`, error);\r\n      lastError = error instanceof Error ? error : new Error(String(error));\r\n      // Continue to next instance\r\n    }\r\n  }\r\n  \r\n  // If we reach here, all instances failed\r\n  console.error(\"All Invidious instances failed for search\");\r\n  throw lastError || new Error(\"All Invidious instances failed\");\r\n}\r\n\r\n// Function to get streaming URLs for a video\r\nexport async function getVideoStreams(videoId: string): Promise<InvidiousStreamInfo> {\r\n  let lastError: Error | null = null;\r\n  \r\n  // Try each instance until one works\r\n  for (const instance of INVIDIOUS_INSTANCES) {\r\n    try {\r\n      console.log(`Getting video stream from Invidious instance: ${instance}`);\r\n      const response = await fetch(`${instance}/api/v1/videos/${videoId}`, {\r\n        cache: 'no-store',\r\n        next: { revalidate: 0 },\r\n        signal: AbortSignal.timeout(5000) // 5 second timeout\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        console.warn(`Instance ${instance} returned status: ${response.status}`);\r\n        lastError = new Error(`Instance ${instance} returned status: ${response.status}`);\r\n        continue; // Try the next instance\r\n      }\r\n      \r\n      const data = await response.json() as InvidiousStreamInfo;\r\n      return data;\r\n    } catch (error) {\r\n      console.warn(`Get video stream with instance ${instance} failed:`, error);\r\n      lastError = error instanceof Error ? error : new Error(String(error));\r\n      // Continue to next instance\r\n    }\r\n  }\r\n  \r\n  // If we reach here, all instances failed\r\n  console.error(\"All Invidious instances failed for video streams\");\r\n  throw lastError || new Error(\"All Invidious instances failed\");\r\n}\r\n\r\n// Function to get the best audio stream URL\r\nexport function getBestAudioStream(streamInfo: InvidiousStreamInfo): string | null {\r\n  // First try to get an audio-only stream from adaptive formats\r\n  const audioStreams = streamInfo.adaptiveFormats.filter(format => \r\n    format.type.startsWith('audio/') || format.audioQuality\r\n  );\r\n  \r\n  // Sort by bitrate (highest first)\r\n  const sortedStreams = [...audioStreams].sort((a, b) => b.bitrate - a.bitrate);\r\n  \r\n  // Return the URL of the highest quality audio stream, or null if none found\r\n  return sortedStreams.length > 0 ? sortedStreams[0].url : null;\r\n}\r\n\r\n// Check if our service is available (for health check)\r\nexport async function GET() {\r\n  // Try each instance until one works\r\n  for (const instance of INVIDIOUS_INSTANCES) {\r\n    try {\r\n      console.log(`Checking health of Invidious instance: ${instance}`);\r\n      const response = await fetch(`${instance}/api/v1/stats`, {\r\n        cache: 'no-store',\r\n        next: { revalidate: 0 },\r\n        signal: AbortSignal.timeout(3000) // 3 second timeout\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        console.warn(`Instance ${instance} health check failed with status: ${response.status}`);\r\n        continue; // Try the next instance\r\n      }\r\n      \r\n      const stats = await response.json();\r\n      return NextResponse.json({ \r\n        status: \"ok\",\r\n        instance,\r\n        stats: {\r\n          version: stats.version,\r\n          software: stats.software\r\n        }\r\n      });\r\n    } catch (error) {\r\n      console.warn(`Health check for instance ${instance} failed:`, error);\r\n      // Continue to next instance\r\n    }\r\n  }\r\n  \r\n  // If we reach here, all instances failed\r\n  console.error(\"All Invidious instances failed health check\");\r\n  return NextResponse.json(\r\n    { error: \"All Invidious API instances are not responding\" }, \r\n    { status: 503 }\r\n  );\r\n} "],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 187, "column": 0}, "map": {"version":3,"sources":["file://D%3A/Soundify/src/app/api/piped/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\r\n\r\n// Define interfaces for Piped API responses\r\ninterface PipedVideo {\r\n  url: string;\r\n  title: string;\r\n  thumbnail: string;\r\n  uploaderName: string;\r\n  uploaderUrl: string;\r\n  uploaderAvatar: string;\r\n  uploadedDate: string;\r\n  duration: number;\r\n  views: number;\r\n  uploaded: number;\r\n  uploaderVerified: boolean;\r\n  isShort: boolean;\r\n}\r\n\r\ninterface PipedSearchResult {\r\n  items: PipedVideo[];\r\n  nextpage: string | null;\r\n  suggestion: string | null;\r\n  corrected: boolean;\r\n}\r\n\r\ninterface PipedStreamFormat {\r\n  itag: number;\r\n  mimeType: string;\r\n  bitrate: number;\r\n  width: number;\r\n  height: number;\r\n  initStart: number;\r\n  initEnd: number;\r\n  indexStart: number;\r\n  indexEnd: number;\r\n  quality: string;\r\n  fps: number;\r\n  url: string;\r\n  audioTrack?: {\r\n    audioChannels: number;\r\n    audioQuality: string;\r\n    audioSampleRate: number;\r\n  };\r\n}\r\n\r\ninterface PipedStreamInfo {\r\n  title: string;\r\n  description: string;\r\n  uploadDate: string;\r\n  uploader: string;\r\n  uploaderUrl: string;\r\n  uploaderAvatar: string;\r\n  thumbnailUrl: string;\r\n  hls: string | null;\r\n  dash: string | null;\r\n  lbryId: string | null;\r\n  uploaderVerified: boolean;\r\n  duration: number;\r\n  views: number;\r\n  likes: number;\r\n  dislikes: number;\r\n  audioStreams: PipedStreamFormat[];\r\n  videoStreams: PipedStreamFormat[];\r\n}\r\n\r\n// List of Piped instances from https://github.com/TeamPiped/documentation/blob/main/content/docs/public-instances/index.md\r\nconst PIPED_INSTANCES = [\r\n  \"https://pipedapi.nosebs.ru\",\r\n  \"https://pipedapi.drgns.space\",\r\n  \"https://pipedapi.ducks.party\",\r\n  \"https://api.piped.private.coffee\",\r\n  \"https://pipedapi.orangenet.cc\"\r\n];\r\n\r\n// Function to search for videos\r\nexport async function searchVideos(query: string): Promise<PipedVideo[]> {\r\n  let lastError: Error | null = null;\r\n  \r\n  // Try each instance until one works\r\n  for (const instance of PIPED_INSTANCES) {\r\n    try {\r\n      console.log(`Searching using Piped instance: ${instance}`);\r\n      const response = await fetch(`${instance}/search?q=${encodeURIComponent(query)}&filter=videos`, {\r\n        cache: 'no-store',\r\n        next: { revalidate: 0 },\r\n        signal: AbortSignal.timeout(5000) // 5 second timeout\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        console.warn(`Piped instance ${instance} returned status: ${response.status}`);\r\n        lastError = new Error(`Piped instance ${instance} returned status: ${response.status}`);\r\n        continue; // Try the next instance\r\n      }\r\n      \r\n      // Check content type for debugging\r\n      const contentType = response.headers.get('content-type');\r\n      if (!contentType || !contentType.includes('application/json')) {\r\n        console.warn(`Piped instance ${instance} returned non-JSON content type: ${contentType}`);\r\n        \r\n        // Get some response text for debugging\r\n        const text = await response.text();\r\n        console.warn(`Response starts with: ${text.substring(0, 100)}`);\r\n        \r\n        lastError = new Error(`Piped instance ${instance} returned non-JSON content: ${contentType}`);\r\n        continue; // Try the next instance\r\n      }\r\n      \r\n      // Parse JSON after ensuring it's the right content type\r\n      const data = JSON.parse(await response.text()) as PipedSearchResult;\r\n      return data.items;\r\n    } catch (error) {\r\n      console.warn(`Search with Piped instance ${instance} failed:`, error);\r\n      lastError = error instanceof Error ? error : new Error(String(error));\r\n      // Continue to next instance\r\n    }\r\n  }\r\n  \r\n  // If we reach here, all instances failed\r\n  console.error(\"All Piped instances failed for search\");\r\n  throw lastError || new Error(\"All Piped instances failed\");\r\n}\r\n\r\n// Function to get streaming URLs for a video\r\nexport async function getVideoStreams(videoId: string): Promise<PipedStreamInfo> {\r\n  let lastError: Error | null = null;\r\n  \r\n  // Try each instance until one works\r\n  for (const instance of PIPED_INSTANCES) {\r\n    try {\r\n      console.log(`Getting video stream from Piped instance: ${instance}`);\r\n      const response = await fetch(`${instance}/streams/${videoId}`, {\r\n        cache: 'no-store',\r\n        next: { revalidate: 0 },\r\n        signal: AbortSignal.timeout(5000) // 5 second timeout\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        console.warn(`Piped instance ${instance} returned status: ${response.status}`);\r\n        lastError = new Error(`Piped instance ${instance} returned status: ${response.status}`);\r\n        continue; // Try the next instance\r\n      }\r\n      \r\n      // Check content type for debugging\r\n      const contentType = response.headers.get('content-type');\r\n      if (!contentType || !contentType.includes('application/json')) {\r\n        console.warn(`Piped instance ${instance} returned non-JSON content type: ${contentType}`);\r\n        \r\n        // Get some response text for debugging\r\n        const text = await response.text();\r\n        console.warn(`Response starts with: ${text.substring(0, 100)}`);\r\n        \r\n        lastError = new Error(`Piped instance ${instance} returned non-JSON content: ${contentType}`);\r\n        continue; // Try the next instance\r\n      }\r\n      \r\n      // Parse JSON after ensuring it's the right content type\r\n      const data = JSON.parse(await response.text()) as PipedStreamInfo;\r\n      return data;\r\n    } catch (error) {\r\n      console.warn(`Get video stream with Piped instance ${instance} failed:`, error);\r\n      lastError = error instanceof Error ? error : new Error(String(error));\r\n      // Continue to next instance\r\n    }\r\n  }\r\n  \r\n  // If we reach here, all instances failed\r\n  console.error(\"All Piped instances failed for video streams\");\r\n  throw lastError || new Error(\"All Piped instances failed\");\r\n}\r\n\r\n// Function to get the best audio stream URL\r\nexport function getBestAudioStream(streamInfo: PipedStreamInfo): string | null {\r\n  // Get audio streams and sort by bitrate (highest first)\r\n  const sortedStreams = [...streamInfo.audioStreams].sort((a, b) => b.bitrate - a.bitrate);\r\n  \r\n  // Return the URL of the highest quality audio stream, or null if none found\r\n  return sortedStreams.length > 0 ? sortedStreams[0].url : null;\r\n}\r\n\r\n// Check if our service is available (for health check)\r\nexport async function GET() {\r\n  // Try each instance until one works\r\n  for (const instance of PIPED_INSTANCES) {\r\n    try {\r\n      console.log(`Checking health of Piped instance: ${instance}`);\r\n      // Just checking if the API responds\r\n      const response = await fetch(`${instance}/config`, {\r\n        cache: 'no-store',\r\n        next: { revalidate: 0 },\r\n        signal: AbortSignal.timeout(3000) // 3 second timeout\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        console.warn(`Piped instance ${instance} health check failed with status: ${response.status}`);\r\n        continue; // Try the next instance\r\n      }\r\n      \r\n      // Check content type for debugging\r\n      const contentType = response.headers.get('content-type');\r\n      if (!contentType || !contentType.includes('application/json')) {\r\n        console.warn(`Piped instance ${instance} returned non-JSON content type: ${contentType}`);\r\n        continue; // Try the next instance\r\n      }\r\n      \r\n      const config = await response.json();\r\n      return NextResponse.json({ \r\n        status: \"ok\",\r\n        instance,\r\n        config\r\n      });\r\n    } catch (error) {\r\n      console.warn(`Health check for Piped instance ${instance} failed:`, error);\r\n      // Continue to next instance\r\n    }\r\n  }\r\n  \r\n  // If we reach here, all instances failed\r\n  console.error(\"All Piped instances failed health check\");\r\n  return NextResponse.json(\r\n    { error: \"All Piped API instances are not responding\" }, \r\n    { status: 503 }\r\n  );\r\n} "],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 341, "column": 0}, "map": {"version":3,"sources":["file://D%3A/Soundify/src/app/api/search/route.ts"],"sourcesContent":["import { type NextRequest, NextResponse } from \"next/server\";\nimport { searchVideos as searchInvidiousVideos } from \"../invidious/route\";\nimport { searchVideos as searchPipedVideos } from \"../piped/route\";\n\n// Our local interface to simplify track handling\ninterface FormattedTrack {\n  id: string;\n  title: string;\n  artist: string;\n  thumbnail: string;\n  duration: number;\n  uri: string;\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const query = searchParams.get(\"query\");\n    \n    if (!query) {\n      return NextResponse.json(\n        { error: \"Query parameter is required\" }, \n        { status: 400 }\n      );\n    }\n    \n    try {\n      let tracks: FormattedTrack[] = [];\n      let usedService = \"invidious\";\n      \n      try {\n        // First try Invidious API\n        console.log(\"Trying to search with Invidious API\");\n        const searchResults = await searchInvidiousVideos(query);\n        \n        if (searchResults && Array.isArray(searchResults) && searchResults.length > 0) {\n          // Format the Invidious results\n          tracks = searchResults.map(video => {\n            // Get the best thumbnail\n            const thumbnail = video.videoThumbnails.find(t => t.quality === 'medium')?.url || \n                              video.videoThumbnails[0]?.url || \n                              `https://i.ytimg.com/vi/${video.videoId}/hqdefault.jpg`;\n                              \n            return {\n              id: video.videoId,\n              title: video.title || 'Unknown Title',\n              artist: video.author || 'Unknown Artist',\n              thumbnail,\n              duration: video.lengthSeconds || 0,\n              uri: `https://www.youtube.com/watch?v=${video.videoId}`\n            };\n          });\n        }\n      } catch (invidiousError) {\n        console.warn(\"Invidious search failed, falling back to Piped API:\", invidiousError);\n        \n        // If Invidious fails, try Piped API\n        try {\n          console.log(\"Trying to search with Piped API\");\n          const pipedResults = await searchPipedVideos(query);\n          \n          if (pipedResults && Array.isArray(pipedResults) && pipedResults.length > 0) {\n            usedService = \"piped\";\n            \n            // Format the Piped results\n            tracks = pipedResults.map(video => {\n              // Extract the video ID from the URL\n              // URL format: /watch?v=VIDEO_ID\n              const videoId = new URL(video.url, \"https://youtube.com\").searchParams.get(\"v\") || \"\";\n              \n              return {\n                id: videoId,\n                title: video.title || 'Unknown Title',\n                artist: video.uploaderName || 'Unknown Artist',\n                thumbnail: video.thumbnail || `https://i.ytimg.com/vi/${videoId}/hqdefault.jpg`,\n                duration: video.duration || 0,\n                uri: `https://www.youtube.com/watch?v=${videoId}`\n              };\n            });\n          }\n        } catch (pipedError) {\n          console.error(\"Both Invidious and Piped search failed:\", pipedError);\n          throw new Error(\"All search services failed\");\n        }\n      }\n      \n      return NextResponse.json({ \n        tracks,\n        service: usedService \n      });\n    } catch (error) {\n      console.error(\"Search method error:\", error);\n      console.error(\"Error details:\", error instanceof Error ? error.stack : String(error));\n      \n      const errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n      \n      return NextResponse.json(\n        { error: `Search failed: ${errorMessage}` }, \n        { status: 500 }\n      );\n    }\n  } catch (error) {\n    console.error(\"Search error:\", error);\n    const errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n    return NextResponse.json(\n      { error: `Failed to search tracks: ${errorMessage}` }, \n      { status: 500 }\n    );\n  }\n} "],"names":[],"mappings":"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","debugId":null}}]
}