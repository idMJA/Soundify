{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 140, "column": 0}, "map": {"version":3,"sources":["file://D%3A/Soundify/src/app/lib/lavalink.ts"],"sourcesContent":["import { Shoukaku } from 'shoukaku';\r\nimport type { Node, Player, NodeOption } from 'shoukaku';\r\n\r\n// Define the Nodes configuration\r\nconst Nodes = [\r\n  {\r\n    name: 'Lavalink',\r\n    url: process.env.LAVALINK_URL || 'localhost:2333',\r\n    auth: process.env.LAVALINK_PASSWORD || 'youshallnotpass',\r\n    secure: process.env.LAVALINK_SECURE === 'true',\r\n  },\r\n];\r\n\r\n// Create a class to manage Lavalink connections\r\nclass LavalinkManager {\r\n  private static instance: LavalinkManager;\r\n  private shoukaku: Shoukaku | null = null;\r\n  private initialized = false;\r\n  private players: Map<string, Player> = new Map();\r\n\r\n  private constructor() {\r\n    // Private constructor to enforce singleton\r\n  }\r\n\r\n  // Get singleton instance\r\n  public static getInstance(): LavalinkManager {\r\n    if (!LavalinkManager.instance) {\r\n      LavalinkManager.instance = new LavalinkManager();\r\n    }\r\n    return LavalinkManager.instance;\r\n  }\r\n\r\n  // Initialize connection to Lavalink\r\n  // Since we can't use the Discord.js connector directly in Next.js,\r\n  // we use a custom connector implementation\r\n  public initialize(): void {\r\n    if (this.initialized) return;\r\n\r\n    try {\r\n      // Create the connector object required by Shoukaku v4\r\n      const connector = {\r\n        send: () => Promise.resolve(),\r\n        sendWS: () => Promise.resolve(),\r\n        configureResuming: () => Promise.resolve(),\r\n        userId: 'web-client',\r\n        guildId: () => 'web-guild',\r\n        channelId: () => 'web-channel',\r\n        shardId: () => 0\r\n      };\r\n\r\n      // Initialize Shoukaku\r\n      // @ts-ignore - Custom connector for web usage with Shoukaku v4\r\n      this.shoukaku = new Shoukaku(connector, Nodes, {\r\n        resumeTimeout: 30,\r\n        resumeByLibrary: true,\r\n        reconnectTries: 3,\r\n        reconnectInterval: 5000,\r\n        restTimeout: 10000,\r\n      });\r\n\r\n      // Handle errors and connection events\r\n      this.shoukaku.on('error', (_, error) => console.error('Lavalink error:', error));\r\n      this.shoukaku.on('ready', (name) => console.log(`Lavalink node ${name} is ready`));\r\n      this.shoukaku.on('disconnect', (name) => console.log(`Lavalink node ${name} disconnected`));\r\n\r\n      this.initialized = true;\r\n      console.log('Lavalink manager initialized');\r\n    } catch (error) {\r\n      console.error('Failed to initialize Lavalink manager:', error);\r\n      this.initialized = false;\r\n    }\r\n  }\r\n\r\n  // Get a Lavalink node\r\n  public async getNode(): Promise<Node | null> {\r\n    if (!this.shoukaku || !this.initialized) {\r\n      this.initialize();\r\n    }\r\n    \r\n    if (!this.shoukaku) return null;\r\n    const nodes = Array.from(this.shoukaku.nodes.values());\r\n    \r\n    return nodes.length > 0 ? nodes[0] : null;\r\n  }\r\n\r\n  // Play a track by URL or search term\r\n  public async play(\r\n    sessionId: string,\r\n    query: string,\r\n    options?: {\r\n      noReplace?: boolean;\r\n      pause?: boolean;\r\n      volume?: number;\r\n    }\r\n  ): Promise<{ track: Record<string, any>; player: Player }> {\r\n    const node = await this.getNode();\r\n    \r\n    if (!node) {\r\n      throw new Error('No Lavalink nodes available');\r\n    }\r\n\r\n    let player = this.players.get(sessionId);\r\n    \r\n    if (!player) {\r\n      if (!this.shoukaku) {\r\n        throw new Error('Shoukaku is not initialized');\r\n      }\r\n      \r\n      player = await this.shoukaku.joinVoiceChannel({\r\n        guildId: sessionId,\r\n        channelId: 'web-channel',\r\n        shardId: 0\r\n      });\r\n      \r\n      if (!player) {\r\n        throw new Error('Failed to create player');\r\n      }\r\n\r\n      this.players.set(sessionId, player);\r\n      \r\n      player.on('exception', (error) => console.error('Player exception:', error));\r\n      player.on('end', () => {\r\n        console.log('Track ended for session', sessionId);\r\n      });\r\n    }\r\n\r\n    // Search for tracks safely with type casting\r\n    const result = await node.rest.resolve(query) as any;\r\n    \r\n    // Check for results, handle different response types from Shoukaku v4\r\n    if (!result) {\r\n      throw new Error('No results found');\r\n    }\r\n    \r\n    // Safely extract track information\r\n    let trackData;\r\n    \r\n    if (result.tracks && Array.isArray(result.tracks) && result.tracks.length > 0) {\r\n      trackData = result.tracks[0];\r\n    } else if (result.track) {\r\n      trackData = result.track;\r\n    } else {\r\n      throw new Error('No tracks found in the response');\r\n    }\r\n    \r\n    // Play the track with error handling\r\n    try {\r\n      const trackParam = typeof trackData === 'string' \r\n        ? trackData \r\n        : (trackData.encoded || trackData.track || trackData);\r\n      \r\n      await player.playTrack({ track: trackParam });\r\n    } catch (error) {\r\n      console.error('Error playing track:', error);\r\n      throw new Error('Failed to play track');\r\n    }\r\n    \r\n    // Set volume if provided\r\n    if (options?.volume !== undefined) {\r\n      await player.setGlobalVolume(options.volume);\r\n    }\r\n    \r\n    return { track: trackData, player };\r\n  }\r\n\r\n  // Stop playback for a session\r\n  public async stop(sessionId: string): Promise<boolean> {\r\n    const player = this.players.get(sessionId);\r\n    if (player) {\r\n      await player.stopTrack();\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // Pause playback for a session\r\n  public async pause(sessionId: string, shouldPause = true): Promise<boolean> {\r\n    const player = this.players.get(sessionId);\r\n    if (player) {\r\n      await player.setPaused(shouldPause);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // Set volume for a session\r\n  public async setVolume(sessionId: string, volume: number): Promise<boolean> {\r\n    const player = this.players.get(sessionId);\r\n    if (player) {\r\n      await player.setGlobalVolume(volume);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // Get current player for a session\r\n  public getPlayer(sessionId: string): Player | undefined {\r\n    return this.players.get(sessionId);\r\n  }\r\n\r\n  // Destroy player for a session\r\n  public async destroyPlayer(sessionId: string): Promise<boolean> {\r\n    const player = this.players.get(sessionId);\r\n    if (player && this.shoukaku) {\r\n      await this.shoukaku.leaveVoiceChannel(sessionId);\r\n      this.players.delete(sessionId);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // Search for tracks\r\n  public async search(query: string): Promise<Record<string, any>> {\r\n    const node = await this.getNode();\r\n    if (!node) {\r\n      throw new Error('No Lavalink nodes available');\r\n    }\r\n\r\n    const result = await node.rest.resolve(query) as any;\r\n    if (!result) {\r\n      throw new Error('Failed to resolve query');\r\n    }\r\n    \r\n    return result;\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const lavalinkManager = LavalinkManager.getInstance();\r\n\r\n// Initialize on import\r\nif (typeof window === 'undefined') {\r\n  // Only initialize on the server-side\r\n  lavalinkManager.initialize();\r\n} "],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 340, "column": 0}, "map": {"version":3,"sources":["file://D%3A/Soundify/src/app/api/lavalink/search/route.ts"],"sourcesContent":["import { type NextRequest, NextResponse } from 'next/server';\r\nimport { lavalinkManager } from '../../../lib/lavalink';\r\n\r\nexport async function GET(request: NextRequest) {\r\n  try {\r\n    const searchParams = request.nextUrl.searchParams;\r\n    const query = searchParams.get('query');\r\n\r\n    if (!query) {\r\n      return NextResponse.json(\r\n        { error: 'Query parameter is required' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // Search for tracks via Lavalink\r\n    const results = await lavalinkManager.search(query);\r\n\r\n    return NextResponse.json({\r\n      status: 'success',\r\n      tracks: results.tracks,\r\n      playlistInfo: results.playlistInfo,\r\n      loadType: results.loadType,\r\n    });\r\n  } catch (error) {\r\n    console.error('Lavalink search error:', error);\r\n    return NextResponse.json(\r\n      { error: 'Failed to search for tracks' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n} "],"names":[],"mappings":";;;AAAA;AACA;;;AAEO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,eAAe,QAAQ,OAAO,CAAC,YAAY;QACjD,MAAM,QAAQ,aAAa,GAAG,CAAC;QAE/B,IAAI,CAAC,OAAO;YACV,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA8B,GACvC;gBAAE,QAAQ;YAAI;QAElB;QAEA,iCAAiC;QACjC,MAAM,UAAU,MAAM,+HAAA,CAAA,kBAAe,CAAC,MAAM,CAAC;QAE7C,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACvB,QAAQ;YACR,QAAQ,QAAQ,MAAM;YACtB,cAAc,QAAQ,YAAY;YAClC,UAAU,QAAQ,QAAQ;QAC5B;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,0BAA0B;QACxC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA8B,GACvC;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}