module.exports = {

"[project]/.next-internal/server/app/api/lavalink/search/route/actions.js [app-rsc] (server actions loader, ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route.runtime.dev.js [external] (next/dist/compiled/next-server/app-route.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page.runtime.dev.js [external] (next/dist/compiled/next-server/app-page.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[externals]/https [external] (https, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}}),
"[externals]/http [external] (http, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}}),
"[externals]/net [external] (net, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}}),
"[externals]/tls [external] (tls, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[project]/src/app/lib/lavalink.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "lavalinkManager": (()=>lavalinkManager)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$shoukaku$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/shoukaku/dist/index.mjs [app-route] (ecmascript)");
;
// Define the Nodes configuration
const Nodes = [
    {
        name: 'Lavalink',
        url: process.env.LAVALINK_URL || 'localhost:2333',
        auth: process.env.LAVALINK_PASSWORD || 'youshallnotpass',
        secure: process.env.LAVALINK_SECURE === 'true'
    }
];
// Create a class to manage Lavalink connections
class LavalinkManager {
    static instance;
    shoukaku = null;
    initialized = false;
    players = new Map();
    constructor(){
    // Private constructor to enforce singleton
    }
    // Get singleton instance
    static getInstance() {
        if (!LavalinkManager.instance) {
            LavalinkManager.instance = new LavalinkManager();
        }
        return LavalinkManager.instance;
    }
    // Initialize connection to Lavalink
    // Since we can't use the Discord.js connector directly in Next.js,
    // we use a custom connector implementation
    initialize() {
        if (this.initialized) return;
        try {
            // Create the connector object required by Shoukaku v4
            const connector = {
                send: ()=>Promise.resolve(),
                sendWS: ()=>Promise.resolve(),
                configureResuming: ()=>Promise.resolve(),
                userId: 'web-client',
                guildId: ()=>'web-guild',
                channelId: ()=>'web-channel',
                shardId: ()=>0
            };
            // Initialize Shoukaku
            // @ts-ignore - Custom connector for web usage with Shoukaku v4
            this.shoukaku = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$shoukaku$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Shoukaku"](connector, Nodes, {
                resumeTimeout: 30,
                resumeByLibrary: true,
                reconnectTries: 3,
                reconnectInterval: 5000,
                restTimeout: 10000
            });
            // Handle errors and connection events
            this.shoukaku.on('error', (_, error)=>console.error('Lavalink error:', error));
            this.shoukaku.on('ready', (name)=>console.log(`Lavalink node ${name} is ready`));
            this.shoukaku.on('disconnect', (name)=>console.log(`Lavalink node ${name} disconnected`));
            this.initialized = true;
            console.log('Lavalink manager initialized');
        } catch (error) {
            console.error('Failed to initialize Lavalink manager:', error);
            this.initialized = false;
        }
    }
    // Get a Lavalink node
    async getNode() {
        if (!this.shoukaku || !this.initialized) {
            this.initialize();
        }
        if (!this.shoukaku) return null;
        const nodes = Array.from(this.shoukaku.nodes.values());
        return nodes.length > 0 ? nodes[0] : null;
    }
    // Play a track by URL or search term
    async play(sessionId, query, options) {
        const node = await this.getNode();
        if (!node) {
            throw new Error('No Lavalink nodes available');
        }
        let player = this.players.get(sessionId);
        if (!player) {
            if (!this.shoukaku) {
                throw new Error('Shoukaku is not initialized');
            }
            player = await this.shoukaku.joinVoiceChannel({
                guildId: sessionId,
                channelId: 'web-channel',
                shardId: 0
            });
            if (!player) {
                throw new Error('Failed to create player');
            }
            this.players.set(sessionId, player);
            player.on('exception', (error)=>console.error('Player exception:', error));
            player.on('end', ()=>{
                console.log('Track ended for session', sessionId);
            });
        }
        // Search for tracks safely with type casting
        const result = await node.rest.resolve(query);
        // Check for results, handle different response types from Shoukaku v4
        if (!result) {
            throw new Error('No results found');
        }
        // Safely extract track information
        let trackData;
        if (result.tracks && Array.isArray(result.tracks) && result.tracks.length > 0) {
            trackData = result.tracks[0];
        } else if (result.track) {
            trackData = result.track;
        } else {
            throw new Error('No tracks found in the response');
        }
        // Play the track with error handling
        try {
            const trackParam = typeof trackData === 'string' ? trackData : trackData.encoded || trackData.track || trackData;
            await player.playTrack({
                track: trackParam
            });
        } catch (error) {
            console.error('Error playing track:', error);
            throw new Error('Failed to play track');
        }
        // Set volume if provided
        if (options?.volume !== undefined) {
            await player.setGlobalVolume(options.volume);
        }
        return {
            track: trackData,
            player
        };
    }
    // Stop playback for a session
    async stop(sessionId) {
        const player = this.players.get(sessionId);
        if (player) {
            await player.stopTrack();
            return true;
        }
        return false;
    }
    // Pause playback for a session
    async pause(sessionId, shouldPause = true) {
        const player = this.players.get(sessionId);
        if (player) {
            await player.setPaused(shouldPause);
            return true;
        }
        return false;
    }
    // Set volume for a session
    async setVolume(sessionId, volume) {
        const player = this.players.get(sessionId);
        if (player) {
            await player.setGlobalVolume(volume);
            return true;
        }
        return false;
    }
    // Get current player for a session
    getPlayer(sessionId) {
        return this.players.get(sessionId);
    }
    // Destroy player for a session
    async destroyPlayer(sessionId) {
        const player = this.players.get(sessionId);
        if (player && this.shoukaku) {
            await this.shoukaku.leaveVoiceChannel(sessionId);
            this.players.delete(sessionId);
            return true;
        }
        return false;
    }
    // Search for tracks
    async search(query) {
        const node = await this.getNode();
        if (!node) {
            throw new Error('No Lavalink nodes available');
        }
        const result = await node.rest.resolve(query);
        if (!result) {
            throw new Error('Failed to resolve query');
        }
        return result;
    }
}
const lavalinkManager = LavalinkManager.getInstance();
// Initialize on import
if ("TURBOPACK compile-time truthy", 1) {
    // Only initialize on the server-side
    lavalinkManager.initialize();
}
}}),
"[project]/src/app/api/lavalink/search/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "GET": (()=>GET)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$lavalink$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/app/lib/lavalink.ts [app-route] (ecmascript)");
;
;
async function GET(request) {
    try {
        const searchParams = request.nextUrl.searchParams;
        const query = searchParams.get('query');
        if (!query) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Query parameter is required'
            }, {
                status: 400
            });
        }
        // Search for tracks via Lavalink
        const results = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$lavalink$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["lavalinkManager"].search(query);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            status: 'success',
            tracks: results.tracks,
            playlistInfo: results.playlistInfo,
            loadType: results.loadType
        });
    } catch (error) {
        console.error('Lavalink search error:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Failed to search for tracks'
        }, {
            status: 500
        });
    }
}
}}),

};

//# sourceMappingURL=%5Broot%20of%20the%20server%5D__34023024._.js.map